# HOP-40 | COLLECTOR - Aggregate & Report

> **Module**: COLLECTOR
> **Version**: 1.0.0
> **Layer**: Output Processing

---

## IDENTITY

```
┌─────────────────────────────────────────────────────────┐
│  COLLECTOR - "Eu agrego. Eu documento. Eu reporto."     │
│                                                         │
│  INPUT:  Spawn results from all tasks                   │
│  OUTPUT: Aggregated report + voice summary              │
│                                                         │
│  INTEGRATES: Voice TTS, File system, Report templates   │
└─────────────────────────────────────────────────────────┘
```

---

## INPUT_CONTRACT

```yaml
$spawn_results:
  type: object
  from: HOP-30 SPAWNER
  required:
    - plan_id
    - results
    - aggregated_quality
```

---

## OUTPUT_CONTRACT

```yaml
$final_report:
  type: object
  schema:
    plan_id: string
    status: string            # "success", "partial", "failed"
    summary: string           # Human-readable summary
    metrics:
      total_tasks: number
      completed: number
      failed: number
      avg_quality: number
      total_time_ms: number
    outputs:
      files: array            # List of generated files
      reports: string         # Path to consolidated report
    voice_report: string      # Text for TTS
    next_steps: array         # Suggested follow-ups
```

---

## AGGREGATION RULES

### 1. Consolidate Outputs

```javascript
function consolidateOutputs(results) {
  const byAgent = groupBy(results, 'agent');
  const byPhase = groupBy(results, 'phase');

  return {
    by_agent: Object.entries(byAgent).map(([agent, tasks]) => ({
      agent,
      count: tasks.length,
      avg_quality: avg(tasks.map(t => t.quality_score)),
      outputs: tasks.map(t => t.output_file)
    })),
    by_phase: Object.entries(byPhase).map(([phase, tasks]) => ({
      phase: parseInt(phase),
      status: tasks.every(t => t.status === 'completed') ? 'completed' : 'partial',
      tasks: tasks.length
    }))
  };
}
```

### 2. Generate Summary

```javascript
function generateSummary(results, plan) {
  const completed = results.filter(r => r.status === 'completed').length;
  const failed = results.filter(r => r.status === 'failed').length;
  const avgQuality = avg(results.map(r => r.quality_score));

  let status = 'success';
  if (failed > 0 && completed === 0) status = 'failed';
  else if (failed > 0) status = 'partial';

  return {
    status,
    text: `Executado ${plan.action}: ${completed}/${results.length} tarefas completadas. ` +
          `Qualidade média: ${avgQuality.toFixed(1)}/10. ` +
          (failed > 0 ? `${failed} falharam.` : 'Sem falhas.')
  };
}
```

### 3. Create Report Document

```markdown
# Execution Report: {{plan_id}}

**Date**: {{timestamp}}
**Action**: {{action}}
**Status**: {{status}}

## Summary
{{summary_text}}

## Metrics
| Metric | Value |
|--------|-------|
| Total Tasks | {{total_tasks}} |
| Completed | {{completed}} |
| Failed | {{failed}} |
| Avg Quality | {{avg_quality}}/10 |
| Total Time | {{total_time}} |

## Outputs by Agent
{{#each by_agent}}
### {{agent}}
- Tasks: {{count}}
- Quality: {{avg_quality}}/10
- Files:
{{#each outputs}}
  - {{this}}
{{/each}}
{{/each}}

## Phase Summary
{{#each by_phase}}
- Phase {{phase}}: {{status}} ({{tasks}} tasks)
{{/each}}

## Generated Files
{{#each files}}
- {{this}}
{{/each}}

## Next Steps
{{#each next_steps}}
- {{this}}
{{/each}}

---
Generated by CODEXA.app at {{timestamp}}
```

---

## VOICE REPORT

### Generate Voice Summary

```javascript
function generateVoiceReport(summary, metrics) {
  const { status, completed, failed, avg_quality, total_time_ms } = metrics;

  // Keep it brief for voice
  const timeStr = formatDuration(total_time_ms);

  if (status === 'success') {
    return `Pronto! ${completed} tarefas completadas em ${timeStr}. ` +
           `Qualidade média ${avg_quality.toFixed(1)} de 10. Sem falhas.`;
  } else if (status === 'partial') {
    return `Finalizado com avisos. ${completed} tarefas OK, ${failed} falharam. ` +
           `Qualidade média ${avg_quality.toFixed(1)}. Verifique os detalhes.`;
  } else {
    return `Atenção: execução falhou. ${failed} tarefas com erro. ` +
           `Verifique o relatório para detalhes.`;
  }
}
```

### Speak Report

```javascript
async function speakReport(voiceText) {
  if (plan.flags.voice) {
    await voice.tts.speak(voiceText);
  }
}
```

---

## SAVE ARTIFACTS

### Save Consolidated Report

```javascript
async function saveReport(report) {
  const reportPath = `outputs/reports/${report.plan_id}_report.md`;
  const reportJson = `outputs/reports/${report.plan_id}_report.json`;

  // Save markdown report
  await fs.writeFile(reportPath, renderTemplate('report_template', report));

  // Save JSON for programmatic access
  await fs.writeFile(reportJson, JSON.stringify(report, null, 2));

  return { md: reportPath, json: reportJson };
}
```

### Archive Task Outputs

```javascript
async function archiveOutputs(results) {
  const batchDir = `outputs/batch_${new Date().toISOString().split('T')[0]}`;
  await fs.mkdir(batchDir, { recursive: true });

  // Copy all outputs to batch folder
  for (const result of results) {
    if (result.output_file) {
      await fs.copy(result.output_file, `${batchDir}/${path.basename(result.output_file)}`);
    }
  }

  return batchDir;
}
```

---

## NEXT STEPS GENERATION

```javascript
function suggestNextSteps(results, plan) {
  const nextSteps = [];

  // Based on what was done
  if (plan.action === 'product_launch') {
    nextSteps.push('Revisar anúncios gerados em outputs/anuncios/');
    nextSteps.push('Publicar via /codexa "Publique os anúncios aprovados"');
  }

  if (plan.action === 'brand_creation') {
    nextSteps.push('Revisar estratégia de marca em outputs/brand/');
    nextSteps.push('Gerar materiais visuais com /prime-photo');
  }

  // If there were failures
  const failed = results.filter(r => r.status === 'failed');
  if (failed.length > 0) {
    nextSteps.push(`Verificar ${failed.length} tarefas que falharam`);
    nextSteps.push('Reexecutar com /codexa --retry "..."');
  }

  // Quality improvements
  const lowQuality = results.filter(r => r.quality_score < 8);
  if (lowQuality.length > 0) {
    nextSteps.push(`Melhorar ${lowQuality.length} itens com qualidade < 8.0`);
  }

  return nextSteps;
}
```

---

## EXAMPLE FINAL OUTPUT

```yaml
Final Report:
  plan_id: "uuid-123"
  status: "success"
  summary: "Executado product_launch: 40/40 tarefas completadas. Qualidade média: 8.3/10. Sem falhas."
  metrics:
    total_tasks: 40
    completed: 40
    failed: 0
    avg_quality: 8.3
    total_time_ms: 1260000
  outputs:
    files:
      - "outputs/research/batch_2024-12-02/*.md"
      - "outputs/anuncios/batch_2024-12-02/*.md"
      - "outputs/photos/batch_2024-12-02/*.json"
    reports: "outputs/reports/uuid-123_report.md"
  voice_report: "Pronto! 40 tarefas completadas em 21 minutos. Qualidade média 8.3 de 10. Sem falhas."
  next_steps:
    - "Revisar anúncios gerados em outputs/anuncios/"
    - "Publicar via /codexa \"Publique os anúncios aprovados\""
```

---

## CLOSE THE LOOP

After report:

1. **Voice output** - Speak summary if --voice flag
2. **Display report** - Show markdown to user
3. **Save artifacts** - Persist all outputs
4. **Suggest next steps** - Proactive guidance

```javascript
async function closeLoop(report) {
  // 1. Voice report
  if (flags.voice) {
    await voice.tts.speak(report.voice_report);
  }

  // 2. Display summary
  console.log(report.summary);
  console.log(`\nReport saved: ${report.outputs.reports}`);

  // 3. Next steps
  console.log('\nNext steps:');
  report.next_steps.forEach(step => console.log(`  - ${step}`));

  return report;
}
```

---

**Created**: 2025-12-02
**Depends**: Voice TTS, File system
