#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CODEXA Voice MCP Server v2.0
============================

MCP Server for Claude Code voice integration.
Provides voice tools for accessibility users.

Tools:
    - listen: Capture voice with VAD
    - speak: Text-to-speech with fallback
    - start_voice_loop: Begin continuous mode
    - listen_and_respond: Continuous mode listening
"""

import sys
import os
import asyncio
from pathlib import Path
from typing import Any

# Fix encoding
if sys.platform == 'win32':
    try:
        sys.stdout.reconfigure(encoding='utf-8')
    except Exception:
        pass

# Add voice module to path (this directory)
VOICE_ROOT = Path(__file__).parent
PROJECT_ROOT = VOICE_ROOT.parent.parent  # codexa.gato/
sys.path.insert(0, str(VOICE_ROOT))
sys.path.insert(0, str(PROJECT_ROOT))

# Load environment from project root
from dotenv import load_dotenv
env_path = PROJECT_ROOT / '.env'
load_dotenv(dotenv_path=env_path)

# Import MCP SDK
try:
    from mcp.server import Server
    from mcp.types import Tool, TextContent
    import mcp.server.stdio
except ImportError:
    print("MCP SDK nao instalado. pip install mcp", file=sys.stderr)
    sys.exit(1)

# Import voice modules (from same directory - VOICE_ROOT is in path)
from stt import (
    listen as voice_listen,
    record_audio_with_vad,
    transcribe_audio,
    play_start_beep
)
from tts import speak as voice_speak
from config import (
    EXIT_COMMANDS,
    MSG_ACTIVATED,
    MSG_GOODBYE,
    is_exit_command
)

# Create MCP server
server = Server("codexa-voice")


@server.list_tools()
async def list_tools() -> list[Tool]:
    """List available voice tools."""
    return [
        Tool(
            name="listen",
            description="Capture and transcribe voice input. Returns transcribed text.",
            inputSchema={
                "type": "object",
                "properties": {
                    "duration": {
                        "type": "number",
                        "description": "Max recording duration in seconds (default: 10)",
                        "default": 10
                    },
                    "language": {
                        "type": "string",
                        "description": "Language code (default: 'pt')",
                        "default": "pt"
                    }
                }
            }
        ),
        Tool(
            name="speak",
            description="Speak text using TTS. Auto-selects best provider.",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Text to speak"
                    }
                },
                "required": ["text"]
            }
        ),
        Tool(
            name="start_voice_loop",
            description="Start continuous voice mode. Use for accessibility.",
            inputSchema={
                "type": "object",
                "properties": {
                    "greeting": {
                        "type": "string",
                        "description": "Optional greeting to speak",
                        "default": "Modo voz ativado. Pode falar."
                    }
                }
            }
        ),
        Tool(
            name="listen_and_respond",
            description="Listen for voice command in continuous mode. Returns VOICE_COMMAND, EXIT_VOICE_LOOP, or NO_SPEECH_DETECTED.",
            inputSchema={
                "type": "object",
                "properties": {
                    "max_duration": {
                        "type": "number",
                        "description": "Max recording duration",
                        "default": 15
                    }
                }
            }
        )
    ]


@server.call_tool()
async def call_tool(name: str, arguments: Any) -> list[TextContent]:
    """Handle tool calls."""

    try:
        # ============================================================
        # LISTEN - Capture voice
        # ============================================================
        if name == "listen":
            duration = arguments.get("duration", 10)
            language = arguments.get("language", "pt")

            print(f"Listening for {duration}s...", file=sys.stderr)

            text = voice_listen(duration=duration, language=language)

            if text and text.strip():
                # Check for error messages from transcription
                if text.startswith("ERROR:"):
                    return [TextContent(type="text", text=text)]
                return [TextContent(type="text", text=f"User said: {text}")]
            else:
                return [TextContent(type="text", text="No speech detected.")]

        # ============================================================
        # SPEAK - Text to speech
        # ============================================================
        elif name == "speak":
            text = arguments.get("text", "")

            if not text:
                return [TextContent(type="text", text="No text provided.")]

            print(f"Speaking: {text[:50]}...", file=sys.stderr)

            success = voice_speak(text)

            if success:
                return [TextContent(type="text", text=f"Spoke: {text[:100]}")]
            else:
                return [TextContent(type="text", text="Failed to speak text")]

        # ============================================================
        # START VOICE LOOP - Begin continuous mode
        # ============================================================
        elif name == "start_voice_loop":
            greeting = arguments.get("greeting", MSG_ACTIVATED)

            print("Starting voice loop...", file=sys.stderr)

            # Speak greeting
            voice_speak(greeting)

            return [TextContent(
                type="text",
                text="""VOICE_LOOP_MODE_STARTED

INSTRUCTIONS:
1. Call listen_and_respond to capture voice command
2. Process the command normally
3. Speak a SHORT response using speak (1-2 sentences)
4. Call listen_and_respond again to continue
5. Exit on: "parar", "sair", "exit", "tchau"

KEEP RESPONSES SHORT! User cannot see screen.

EXIT KEYWORDS: parar, sair, exit, quit, stop, encerrar, tchau"""
            )]

        # ============================================================
        # LISTEN AND RESPOND - Continuous mode (uses fixed duration, VAD was unreliable)
        # ============================================================
        elif name == "listen_and_respond":
            max_duration = arguments.get("max_duration", 8)  # Default 8s for continuous

            print(f"Listening (continuous, {max_duration}s)...", file=sys.stderr)

            try:
                # Use fixed duration listen (more reliable than VAD)
                text = voice_listen(duration=max_duration, language="pt", use_vad=False)

                if text and text.strip():
                    # Check for error messages from transcription
                    if text.startswith("ERROR:"):
                        return [TextContent(
                            type="text",
                            text=f"VOICE_ERROR: {text}"
                        )]

                    # Check for exit
                    if is_exit_command(text):
                        voice_speak(MSG_GOODBYE)
                        return [TextContent(
                            type="text",
                            text="EXIT_VOICE_LOOP: User requested exit."
                        )]

                    return [TextContent(
                        type="text",
                        text=f"VOICE_COMMAND: {text}"
                    )]
                else:
                    return [TextContent(
                        type="text",
                        text="NO_SPEECH_DETECTED: Call listen_and_respond again."
                    )]

            except Exception as e:
                print(f"Listen error: {e}", file=sys.stderr)
                return [TextContent(
                    type="text",
                    text=f"LISTEN_ERROR: {str(e)}. Call listen_and_respond to retry."
                )]

        else:
            return [TextContent(type="text", text=f"Unknown tool: {name}")]

    except Exception as e:
        import traceback
        error_msg = f"Error: {str(e)}\n{traceback.format_exc()}"
        print(error_msg, file=sys.stderr)
        return [TextContent(type="text", text=f"Error: {str(e)}")]


async def main():
    """Run the MCP server."""
    print("CODEXA Voice Server v2.0 starting...", file=sys.stderr)
    print("Tools: listen, speak, start_voice_loop, listen_and_respond", file=sys.stderr)

    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            server.create_initialization_options()
        )


if __name__ == "__main__":
    asyncio.run(main())
